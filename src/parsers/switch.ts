import { BlockType, Token, SyntaxError, UnhandledError, removeEmptyWords, generateAutoGeneratedFnName, convert, isNext } from "../convert";
import { convertRightSide, noLeftSpacesRightSpaceOperators, noSpacesOperators, withSpacesOperators } from "./rightSide";

export { convertSwitch }


/**
 * 
 * @param tokens space, line_break, commentを除いたトークン、先頭はswitchであること
 * @param converted 
 * @param assigningVar 変数に代入する形式であるかどうか、代入する場合は変数名、変数の宣言部分は関数の呼び出し元で行う
 * @param isInArg 関数などの引数内であるかどうか
 * @param insertIndex 自動生成の関数を挿入するconvertedにおけるインデックス
 * @param convertBlockFunc 
 * @param indentLevel 
 */
function convertSwitch(tokens: Token[], converted: string[], assigningVar: null | string, isInArg: boolean, insertIndex: number, convertBlockFunc: (tokens: Token[], indentLevel: number, container: BlockType, changeToYieldReturn: boolean) => void, indentLevel: number, indentCount: number): number {
  if (tokens.length === 0) {
    return 0;
  }
  if (tokens[0].text !== 'switch') {
    throw new UnhandledError(tokens[0]);
  }

  if (isInArg) {

  } else {
    let i = 1;

    converted.push('switch (');
    while (true) {
      const param = tokens[i];
      if (param.category === undefined || param.category === 'context_keyword') {
        converted.push(param.text);
      } else
        throw new SyntaxError(param);
      i++;

      const comma = tokens[i];
      if (comma.text === ',') {
        converted.push(', ');
        i++;
      } else if (comma.text === '{') {
        break;
      } else {
        throw new SyntaxError(comma);
      }
    }

    converted.push(') {\r\n');

    while (true) {
      let arrowFound = false;
      let arrowIndex = i;
      for (; arrowIndex < tokens.length; arrowIndex++) {
        arrowIndex = tokens.findIndex((token, index) => index >= arrowIndex && token.text === '=>');
        if (arrowIndex === -1) {
          break;
        }
        const fnCount = tokens.slice(i, arrowIndex).filter(token => token.text === 'fn').length;
        const arrowCount = tokens.slice(i, arrowIndex).filter(token => token.text === '=>').length;
        if (fnCount === arrowCount) {
          arrowFound = true;
          break;
        }
      }
      if (!arrowFound) {
        throw new SyntaxError(tokens[i]);
      }

      converted.push(' '.repeat((indentLevel + 1) * indentCount));
      if (arrowIndex - i === 1 && tokens[i].text === '_') {
        converted.push('default');
      } else {
        converted.push('case ');
        for (let j = i; j < arrowIndex; j++) {
          const token = tokens[j];
          if (j !== arrowIndex - 1) {
            if (token.category === 'operator') {
              if (withSpacesOperators.has(tokens[j].text)) {
                converted.push(` ${token.text} `);
              } else if (noLeftSpacesRightSpaceOperators.has(tokens[j].text)) {
                converted.push(token.text + ' ');
              } else {
                converted.push(token.text);
              }
            } else {
              converted.push(token.text + ' ');
            }
          }
        }
      }
      converted.push(': ');

      i = arrowIndex + 1;

      if (tokens[i].text === '{') {
        converted.push('{\r\n');

        let braceCount = 1;
        let rightBraceIndex = -1;
        for (let j = i + 1; j < tokens.length; j++) {
          if (tokens[j].text === '{') {
            braceCount++;
          } else if (tokens[j].text === '}') {
            braceCount--;
            if (braceCount === 0) {
              rightBraceIndex = j;
              break;
            }
          }
        }
        if (rightBraceIndex === -1) {
          throw new SyntaxError(tokens[i]);
        }
        convertBlockFunc(tokens.slice(i + 1, rightBraceIndex), indentLevel + 1, 'switch', false);
        i = rightBraceIndex + 1;
        converted.push('}\r\n');
      } else {
        converted.push('\r\n');
        if (assigningVar) {
          converted.push(`${assigningVar} = `);
        }
        convertRightSide(tokens.slice(i), converted, convertBlockFunc, indentLevel, indentCount);
        converted.push('break;\r\n');
      }
      return i;
      break;
    }
  }return 0;
}
