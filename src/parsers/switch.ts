import { Token, SyntaxError, UnhandledError, removeEmptyWords, generateAutoGeneratedFnName, isNext, convertBlock, converted, indentCount } from "../convert";
import { findLastIndex } from "./functions";
import { convertRightSide, leftSpaceNoRightSpacesOperators, noLeftSpacesRightSpaceOperators, withSpacesOperators } from "./rightSide";
import { Type, convertType } from "./typeAndVariable";

export { convertSwitch }


/**
 * 
 * @param tokens space, line_break, commentを除く前のswitch文のみを切り出したトークン、先頭はswitchであること
 * @param converted 
 * @param insertIndex 自動生成の関数を挿入するconvertedにおけるインデックス
 * @param assigningVar 変数に代入する形式であるかどうか、代入する場合は{ name: 変数の名前, type: trueならば型推論可能、そうでない場合は変数の型 }、代入しない場合はnull
 * @param shouldStatic 自動生成される関数をstaticにする必要があるかどうか
 * @param indentLevel
 * @returns 自動生成された関数の挿入位置、自動生成されなかった場合はfalse
 */
function convertSwitch(tokens: Token[], insertIndex: number, assigningType: null | true | Type, shouldStatic: boolean, indentLevel: number, changeToYieldReturn = false): { start: number, end: number }[] | false {
  if (tokens.length === 0) {
    return false;
  }
  if (tokens[0].text !== 'switch') {
    throw new UnhandledError(tokens[0]);
  }

  let i = 1;

  const removed = removeEmptyWords(tokens, true);
  const leftBraceIndex = removed.findIndex(token => token.text === '{');
  if (leftBraceIndex === -1) {
    throw new SyntaxError(removed[i]);
  }

  if (assigningType === null) {
    converted.push('switch (');
  }

  const convertStartIndex = tokens.findIndex(token => token.id === removed[i].id);
  const convertEndIndex = tokens.findIndex(token => token.id === removed[leftBraceIndex - 1].id);
  const endAt = convertRightSide(tokens.slice(convertStartIndex, convertEndIndex + 1), insertIndex, assigningType, shouldStatic, indentLevel);
  const unexpectedIndex = tokens.slice(convertStartIndex + endAt.endAt, convertEndIndex + 1).findIndex(token => token.category !== 'space' && token.category !== 'line_break' && token.category !== 'comment');
  if (unexpectedIndex !== -1)
    throw new SyntaxError(tokens.slice(endAt.endAt, convertEndIndex + 1)[unexpectedIndex]);
  if (converted[converted.length - 1] === ';\r\n') {
    converted.pop();
  }

  if (assigningType === null) {
    converted.push(') {\r\n');
    i = leftBraceIndex + 1;

    while (true) {
      let arrowFound = false;
      let arrowIndex = i;
      for (; arrowIndex < removed.length; arrowIndex++) {
        arrowIndex = removed.findIndex((token, index) => index >= arrowIndex && token.text === '=>');
        if (arrowIndex === -1) {
          break;
        }
        const fnCount = removed.slice(i, arrowIndex).filter(token => token.text === 'fn').length;
        const arrowCount = removed.slice(i, arrowIndex).filter(token => token.text === '=>').length;
        if (fnCount === arrowCount) {
          arrowFound = true;
          break;
        }
      }
      if (!arrowFound) {
        throw new SyntaxError(removed[i]);
      }

      converted.push(' '.repeat((indentLevel + 1) * indentCount));
      if (arrowIndex - i === 1 && removed[i].text === '_') {
        converted.push('default');
      } else {
        converted.push('case ');
        for (let j = i; j < arrowIndex; j++) {
          const token = removed[j];
          if (token.category === 'operator') {
            if (withSpacesOperators.has(removed[j].text)) {
              if (j !== arrowIndex - 1)
                converted.push(` ${token.text} `);
              else
                converted.push(' ' + token.text);
            } else if (noLeftSpacesRightSpaceOperators.has(removed[j].text)) {
              if (j !== arrowIndex - 1)
                converted.push(token.text + ' ');
              else
                converted.push(token.text);
            } else if (leftSpaceNoRightSpacesOperators.has(removed[j].text)) {
              converted.push(' ' + token.text);
            } else {
              converted.push(token.text);
            }
          } else {
            if (j !== arrowIndex - 1)
              converted.push(token.text + ' ');
            else
              converted.push(token.text);
          }
        }
      }
      converted.push(': ');

      const nextToArrowIndex = isNext(() => true, true, arrowIndex, removed, false, true) as { result: boolean, index: number };
      if (nextToArrowIndex.index === -1)
        throw new SyntaxError(removed[arrowIndex]);
      i = nextToArrowIndex.index;

      converted.push('{\r\n');

      const isBlock = removed[i].text === '{';
      if (isBlock) {
        let braceCount = 1;
        let rightBraceIndex = -1;
        for (let j = i + 1; j < removed.length; j++) {
          if (removed[j].text === '{') {
            braceCount++;
          } else if (removed[j].text === '}') {
            braceCount--;
            if (braceCount === 0) {
              rightBraceIndex = j;
              break;
            }
          }
        }
        if (rightBraceIndex === -1) {
          throw new SyntaxError(removed[i]);
        }

        const convertStartIndex = tokens.findIndex(token => token.id === removed[i + 1].id);
        const convertEndIndex = tokens.findIndex(token => token.id === removed[rightBraceIndex].id);
        convertBlock(tokens.slice(convertStartIndex, convertEndIndex), 'fn', indentLevel + 2, false, changeToYieldReturn);

        i = rightBraceIndex;
      } else {
        converted.push(' '.repeat((indentLevel + 2) * indentCount));

        const convertStartIndex = tokens.findIndex(token => token.id === removed[i].id);
        const sliced = tokens.slice(convertStartIndex);
        const endAt = convertRightSide(sliced, insertIndex, assigningType, false, indentLevel + 2);

        converted.push(' '.repeat((indentLevel + 2) * indentCount));
        converted.push('break;\r\n');

        const endAtAtRemoved = findLastIndex(removed, token => token.start <= sliced[endAt.endAt].start);

        i = endAtAtRemoved;
      }

      converted.push(' '.repeat((indentLevel + 1) * indentCount));
      converted.push('}\r\n');

      const isEndIndex = isNext(() => true, true, i, removed, false, true) as { result: boolean, index: number };
      if (isEndIndex.index === -1)
        throw new SyntaxError(removed[i]);
      const isEnd = removed[isEndIndex.index];
      if (isEnd.text === '}') {
        converted.push(' '.repeat(indentLevel * indentCount));
        converted.push('}\r\n');
        return false;
      } else if (isEnd.text === ',') {
        const isEndEndIndex = isNext(() => true, true, isEndIndex.index, removed, false, true) as { result: boolean, index: number };
        if (isEndEndIndex.index === -1)
          throw new SyntaxError(removed[i]);
        if (removed[isEndEndIndex.index].text === '}') {
          converted.push(' '.repeat(indentLevel * indentCount));
          converted.push('}\r\n');
          return false;
        }
        i++;
      } else {
        if (isBlock)
          throw new SyntaxError(removed[i]);
      }

      i++;
    }
  } else {
    converted.push(' switch {\r\n');
    i = leftBraceIndex + 1;

    let inserted: { start: number, end: number }[] | false = false;
    while (true) {
      let arrowFound = false;
      let arrowIndex = i;
      for (; arrowIndex < removed.length; arrowIndex++) {
        arrowIndex = removed.findIndex((token, index) => index >= arrowIndex && token.text === '=>');
        if (arrowIndex === -1) {
          break;
        }
        const fnCount = removed.slice(i, arrowIndex).filter(token => token.text === 'fn').length;
        const arrowCount = removed.slice(i, arrowIndex).filter(token => token.text === '=>').length;
        if (fnCount === arrowCount) {
          arrowFound = true;
          break;
        }
      }
      if (!arrowFound) {
        throw new SyntaxError(removed[i]);
      }

      converted.push(' '.repeat((indentLevel + 1) * indentCount));
      for (let j = i; j < arrowIndex; j++) {
        const token = removed[j];
        if (token.category === 'operator') {
          if (withSpacesOperators.has(removed[j].text)) {
            if (j !== arrowIndex - 1)
              converted.push(` ${token.text} `);
            else
              converted.push(' ' + token.text);
          } else if (noLeftSpacesRightSpaceOperators.has(removed[j].text)) {
            if (j !== arrowIndex - 1)
              converted.push(token.text + ' ');
            else
              converted.push(token.text);
          } else if (leftSpaceNoRightSpacesOperators.has(removed[j].text)) {
            converted.push(' ' + token.text);
          } else {
            converted.push(token.text);
          }
        } else {
          if (j !== arrowIndex - 1)
            converted.push(token.text + ' ');
          else
            converted.push(token.text);
        }
      }
      converted.push(' => ');

      const nextToArrowIndex = isNext(() => true, true, arrowIndex, removed, false, true) as { result: boolean, index: number };
      if (nextToArrowIndex.index === -1)
        throw new SyntaxError(removed[arrowIndex]);
      i = nextToArrowIndex.index;

      const isBlock = removed[i].text === '{';
      if (isBlock) {
        if (insertIndex === -1) {
          throw new SyntaxError(removed[i], 'Cannot use block style switch case in this context');
        }

        i = arrowIndex + 1;

        let braceCount = 1;
        let rightBraceIndex = -1;
        for (let j = i + 1; j < removed.length; j++) {
          if (removed[j].text === '{') {
            braceCount++;
          } else if (removed[j].text === '}') {
            braceCount--;
            if (braceCount === 0) {
              rightBraceIndex = j;
              break;
            }
          }
        }
        if (rightBraceIndex === -1) {
          throw new SyntaxError(removed[i]);
        }

        let firstConvertedLength = converted.length;
        const fnName = generateAutoGeneratedFnName();
        converted.push(' '.repeat(indentLevel * indentCount));
        if (assigningType === true) {
          converted.push(`var ${fnName} = () => {\r\n`);
        } else {
          converted.push(`Func<${convertType(assigningType)}> ${fnName} = () => {\r\n`);
        }

        const convertStartIndex = tokens.findIndex(token => token.id === removed[i + 1].id);
        const convertEndIndex = tokens.findIndex(token => token.id === removed[rightBraceIndex].id);
        convertBlock(tokens.slice(convertStartIndex, convertEndIndex), 'fn', indentLevel + 1, false, false);

        converted.push(' '.repeat(indentLevel * indentCount));
        converted.push('};\r\n');

        const toMove = converted.splice(firstConvertedLength);
        converted.splice(insertIndex, 0, ...toMove);
        if (inserted === false) {
          inserted = [];
        }
        inserted.push({ start: insertIndex, end: insertIndex + toMove.length });
        insertIndex += toMove.length;

        converted.push(`${fnName}(),\r\n`);

        i = rightBraceIndex;
      } else {
        const convertStartIndex = tokens.findIndex(token => token.id === removed[i].id);
        const sliced = tokens.slice(convertStartIndex);
        const endAt = convertRightSide(sliced, insertIndex, assigningType, false, indentLevel + 2);

        if (converted[converted.length - 1] === ';\r\n') {
          converted.pop();
        }
        converted.push(',\r\n');

        const endAtAtRemoved = findLastIndex(removed, token => token.start <= sliced[endAt.endAt].start);

        i = endAtAtRemoved;
      }

      const isEndIndex = isNext(() => true, true, i, removed, false, true) as { result: boolean, index: number };
      if (isEndIndex.index === -1)
        throw new SyntaxError(removed[i]);
      const isEnd = removed[isEndIndex.index];
      if (isEnd.text === '}') {
        converted.push(' '.repeat(indentLevel * indentCount));
        converted.push('}');
        return inserted;
      } else if (isEnd.text === ',') {
        const isEndEndIndex = isNext(() => true, true, isEndIndex.index, removed, false, true) as { result: boolean, index: number };
        if (isEndEndIndex.index === -1)
          throw new SyntaxError(removed[i]);
        if (removed[isEndEndIndex.index].text === '}') {
          converted.push(' '.repeat(indentLevel * indentCount));
          converted.push('}');
          return inserted;
        }
        i++;
      } else {
        if (isBlock)
          throw new SyntaxError(removed[i]);
      }

      i++;
    }
  }
}
